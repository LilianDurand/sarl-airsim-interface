/** 
 * 
 */
package io.sarl.airsim

import fr.utbm.airsim.api.DrivetrainType
import fr.utbm.airsim.api.MultirotorClientInterface
import fr.utbm.airsim.api.YawMode
import io.sarl.airsim.influences.MoveByVelocity
import io.sarl.airsim.influences.Takeoff
import io.sarl.airsim.influences.sim.SetVehiclePose
import io.sarl.airsim.perceptions.MultirotorStatePerception
import io.sarl.airsim.perceptions.sim.SimGroundTruthKinematicsPerception
import io.sarl.airsim.perceptions.sim.SimPosePerception
import io.sarl.airsim.simulation.influence.BatchedInfluenceReactionStrategy
import io.sarl.airsim.simulation.allocation.FcfsFixedSizePoolAllocationStrategy
import io.sarl.airsim.simulation.scheduling.SimulationStrategy
import io.sarl.airsim.utils.ActiveWaitLock
import io.sarl.core.DefaultContextInteractions
import io.sarl.core.Initialize
import io.sarl.core.Logging
import io.sarl.core.Schedules
import io.sarl.lang.core.Address
import java.util.Collections
import org.msgpack.rpc.Client
import org.msgpack.rpc.loop.EventLoop

import static io.sarl.airsim.simulation.scheduling.FixedStepBlockingSimulationStrategy.fixedStepBlockingSimulationStrategy

/**
 * Agent in charge of controlling the simulation, transmitting the influences and
 * dispatching the perceptions .
 * This agent has basically 3 main roles and capacities:
 * - Managing the propagation of perceptions and influences
 * - Managing the simulation schedule
 * - Managing the affectation of bodies to agents
 * @author Alexandre Lombard
 * 
 */
agent SimulationControllerAgent {
	
	uses Logging, DefaultContextInteractions, Schedules

	/** The simulation step */
	val simulationStepMs = 100.0

	val affectationStrategy =
			new FcfsFixedSizePoolAllocationStrategy([|
				val pool = newLinkedList("S0", "S1", "S2", "S3", "S4", "S5", "S6", "S7", "S8", "S9")
				Collections.shuffle(pool)
				return pool
			].apply)
	
	var simulationStrategy: SimulationStrategy

	/** The influence/reaction strategy defining when influence and perceptions should be propagated */
//	var influenceReactionStrategy = new DirectInfluenceReactionStrategy()
	/** Perceptions are propagated as soon as they are received, influences as soon as every one has sent one and eventually if the delay is respected */
	var influenceReactionStrategy = new BatchedInfluenceReactionStrategy(
			[t, p|true], [t, i|i.size >= affectationStrategy.affectedBodiesCount], 1, false)
	
	// Attributes used to access AirSim API
	val loop = EventLoop.defaultEventLoop()
	val rpcClient = new Client("127.0.0.1", 41451, loop)
	val multirotorClient = rpcClient.proxy(typeof(MultirotorClientInterface))
	
	on Initialize {
		// Standard scheduling according to the direct influence/reaction strategy (it would also work with Batched but forbidding
		// influences from being applied immediately is not well-suited with real-time simulation)
		// Perceptions are retrieved regularly, simulation runs in real-time
//		this.influenceReactionStrategy = new DirectInfluenceReactionStrategy()
// 		this.schedulingStrategy = new RealTimeSchedulingStrategy[retrievePerceptions]
		
		// Scheduling according to the batched influence/reaction strategy
		// Perceptions are retrieved only after influences have been applied, simulation runs with fixed steps
		
		// At the beginning we started paused
		multirotorClient.simPause(true)

		val influencesPropagated = new ActiveWaitLock()
		influenceReactionStrategy.onInfluencesPropagated[
			info("Influences propagated...")
			influencesPropagated.unlock
		]

		this.simulationStrategy = fixedStepBlockingSimulationStrategy [
			retrievePerceptionsBy = [ retrievePerceptions ]
			pauseBy = [ multirotorClient.simPause(true) ]
			canContinueIf = [!influencesPropagated.isLocked ]
			continueSimulationBy = [ influencesPropagated.lock multirotorClient.simContinueForTime(simulationStepMs)]
		]
		
		// Schedule the loop
		atFixedDelay(simulationStepMs.longValue) [ simulationStrategy.loop ]
	}
	
	/**
	 * When a drone emits the take-off instruction, transfers it to AirSim
	 */
	on Takeoff {
		val body = affectationStrategy.affectOrGetBody(occurrence.source, [a, n|onAffectation(a, n)])
		this.influenceReactionStrategy.influenceReceived(occurrence.source) [
			multirotorClient.takeoffAsync(20.0f, body)
		]
	}

	/** 
	 * When a drone emits the move-by-velocity instruction, transfers it to AirSim
	 */
	on MoveByVelocity {
		val body = affectationStrategy.affectOrGetBody(occurrence.source, [a, n|onAffectation(a, n)])
		this.influenceReactionStrategy.influenceReceived(occurrence.source) [
			multirotorClient.moveByVelocityAsync(
			occurrence.vx, occurrence.vy, occurrence.vz, occurrence.duration, DrivetrainType.MAX_DEGREE_OF_FREEDOM,
			new YawMode(), body)
		]
	}

	/** 
	 * When a drone emits the set-vehicle-pose instruction, transfers it to AirSim
	 */
	on SetVehiclePose {
		val body = affectationStrategy.affectOrGetBody(occurrence.source, [a,n|onAffectation(a,n)])
		this.influenceReactionStrategy.influenceReceived(occurrence.source) [
			multirotorClient.simSetVehiclePose(occurrence.pose, true, body)
		]
	}
	
	/** Retrieve the perceptions for a single agent */
	private def retrieveAgentPerceptions(address : Address, name: String) {
		val state = multirotorClient.getMultirotorState(name)
		val pose = multirotorClient.simGetObjectPose(name)
		val kinematics = multirotorClient.simGetGroundTruthKinematics(name)

		this.influenceReactionStrategy.perceptionReceived(address) [
			emit(new MultirotorStatePerception(state))[it == address]
			emit(new SimPosePerception(pose))[it == address]
			emit(new SimGroundTruthKinematicsPerception(kinematics))[it == address]
		]
	}
	
	/** Retrieve the perceptions for all agents */
	private def retrievePerceptions {
		this.affectationStrategy.affectedBodies.forEach[address, name | retrieveAgentPerceptions(address, name)]
	}
	
	private def onAffectation(address : Address, name : String) {
		info("Received affectation: " + address.UUID + " - " + name)
		multirotorClient.enableApiControl(true, name)

		// Retrieve the initial perceptions for this agent
		retrieveAgentPerceptions(address, name)
	}
}
