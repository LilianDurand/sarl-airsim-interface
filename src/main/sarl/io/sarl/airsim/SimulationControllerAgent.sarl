/** 
 * 
 */
package io.sarl.airsim

import fr.utbm.airsim.api.DrivetrainType
import fr.utbm.airsim.api.MultirotorClientInterface
import fr.utbm.airsim.api.YawMode
import io.sarl.airsim.influences.MoveByVelocity
import io.sarl.airsim.influences.Takeoff
import io.sarl.airsim.perceptions.LidarDataPerception
import io.sarl.core.DefaultContextInteractions
import io.sarl.core.Destroy
import io.sarl.core.Initialize
import io.sarl.core.Logging
import io.sarl.core.Schedules
import io.sarl.lang.core.Address
import org.msgpack.rpc.Client
import org.msgpack.rpc.loop.EventLoop
import io.sarl.airsim.perceptions.MultirotorStatePerception
import io.sarl.airsim.perceptions.sim.SimPosePerception
import io.sarl.airsim.perceptions.sim.SimGroundTruthKinematicsPerception

/**
 * Agent in charge of controlling the simulation, transmitting the influences and
 * dispatching the perceptions 
 * @author Alexandre Lombard
 * 
 */
agent SimulationControllerAgent {
	uses Logging, DefaultContextInteractions, Schedules
	
	// Temporary solution to manage the affectation of the drones to the agents
	val availableDrones = newLinkedList("Alpha", "Bravo", "Charly", "Delta", "Echo")
	val affectedDrones = <Address, String>newHashMap

	val loop = EventLoop.defaultEventLoop()

	val rpcClient = new Client("127.0.0.1", 41451, loop)
	val multirotorClient = rpcClient.proxy(typeof(MultirotorClientInterface))
	
	on Initialize {
		every(100) [
			synchronized (this) {
				// Fetch the lidar data and propagate it
				affectedDrones.mapValues[multirotorClient.getLidarData("Lidar", it)].forEach [ k : Address, v |
					emit(new LidarDataPerception(v))[it == k]
				]

				// Fetch the multirotor state info and propagate it
				affectedDrones.mapValues[multirotorClient.getMultirotorState(it)].forEach [ k : Address, v |
					emit(new MultirotorStatePerception(v))[it == k]
				]

				// Fetch the sim pose and propagate it
				affectedDrones.mapValues[ multirotorClient.simGetObjectPose(it)].forEach [ k : Address, v |
					emit(new SimPosePerception(v))[it == k]
				]

				affectedDrones.mapValues[multirotorClient.simGetGroundTruthKinematics(it)].forEach [ k : Address, v |
					emit(new SimGroundTruthKinematicsPerception(v))[it == k]
				]
			}
		]
	}

	on Destroy {
		//
	}
	
	on Takeoff {
		multirotorClient.takeoffAsync(20.0f, affectOrGetDrone(occurrence.source))
	}
	
	on MoveByVelocity {
		multirotorClient.moveByVelocityAsync(
			occurrence.vx, occurrence.vy, occurrence.vz, occurrence.duration, DrivetrainType.MAX_DEGREE_OF_FREEDOM,
			new YawMode(), affectOrGetDrone(occurrence.source))
	}
	
	synchronized def affectOrGetDrone(address : Address) {
		var name: String
		if (!affectedDrones.containsKey(address)) {
			name = availableDrones.pop()
			info("Received affectation: " + address.UUID + " - " + name)
			affectedDrones.put(address, name)
			multirotorClient.enableApiControl(true, name)
		} else {
			name = affectedDrones.get(address)
		}
			
		return name
	}
}
