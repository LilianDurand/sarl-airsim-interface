/** 
 * 
 */
package io.sarl.airsim

import fr.utbm.airsim.api.DrivetrainType
import fr.utbm.airsim.api.MultirotorClientInterface
import fr.utbm.airsim.api.YawMode
import io.sarl.airsim.influences.MoveByVelocity
import io.sarl.airsim.influences.Takeoff
import io.sarl.airsim.influences.sim.SetVehiclePose
import io.sarl.airsim.perceptions.MultirotorStatePerception
import io.sarl.airsim.perceptions.sim.SimGroundTruthKinematicsPerception
import io.sarl.airsim.perceptions.sim.SimPosePerception
import io.sarl.core.DefaultContextInteractions
import io.sarl.core.Destroy
import io.sarl.core.Initialize
import io.sarl.core.Logging
import io.sarl.core.Schedules
import io.sarl.lang.core.Address
import java.util.Collections
import org.msgpack.rpc.Client
import org.msgpack.rpc.loop.EventLoop
import java.util.concurrent.ConcurrentHashMap

/**
 * Agent in charge of controlling the simulation, transmitting the influences and
 * dispatching the perceptions 
 * @author Alexandre Lombard
 * 
 */
agent SimulationControllerAgent {
	
	uses Logging, DefaultContextInteractions, Schedules
	
	// TODO Manage the simulation schedule: i.e. pause the simulation when the agents are computing their commands, and simulate for a fixed step 
	
	/** The perception period for all drones */
	val perceptionDelayMs = 100
	
	/** The simulation step */
	val simulationStepMs = 100.0
	
	// Temporary solution to manage the affectation of the drones to the agents
	//val availableDrones = newLinkedList("S1", "S3")
	//val availableDrones = newLinkedList("S0", "S1", "S2", "S3")
	val availableDrones = newLinkedList("S0", "S1", "S2", "S3", "S4", "S5", "S6", "S7", "S8", "S9")
	//val availableDrones = newLinkedList("S0", "S1", "S2", "S3", "S4", "S5", "S6", "S7", "S8", "S9", "S10", "S11", "S12", "S13", "S14", "S15", "S16", "S17", "S18", "S19")
	val affectedDrones = new ConcurrentHashMap<Address, String>
	
	/** A map making the link between an address and a flag indicating if an action has been performed */
	val actionFlags = new ConcurrentHashMap<Address, Boolean>
	
	// Attributes used to access AirSim API
	val loop = EventLoop.defaultEventLoop()
	val rpcClient = new Client("127.0.0.1", 41451, loop)
	val multirotorClient = rpcClient.proxy(typeof(MultirotorClientInterface))
	
	on Initialize {
		Collections.shuffle(availableDrones)

		multirotorClient.simPause(true)

		atFixedDelay(perceptionDelayMs) [
			// Fetch the lidar data and propagate it
//			affectedDrones.mapValues[multirotorClient.getLidarData("Lidar", it)].forEach [ k : Address, v |
//				emit(new LidarDataPerception(v))[it == k]
//			]

			// Fetch the multirotor state info and propagate it
			affectedDrones.mapValues[multirotorClient.getMultirotorState(it)].forEach [ k : Address, v |
				emit(new MultirotorStatePerception(v))[it == k]
			]

			// Fetch the sim pose and propagate it
			affectedDrones.mapValues[ multirotorClient.simGetObjectPose(it)].forEach [ k : Address, v |
				emit(new SimPosePerception(v))[it == k]
			]

			affectedDrones.mapValues[multirotorClient.simGetGroundTruthKinematics(it)].forEach [ k : Address, v |
				emit(new SimGroundTruthKinematicsPerception(v))[it == k]
			]
			
			// If each drone has performed an action, we run a simulation step
			if (actionFlagsCount === affectedDrones.size) {
				info("Applying actions...")
				
				resetActionFlags()
				
				multirotorClient.simContinueForTime(simulationStepMs)
				Thread.sleep(simulationStepMs.longValue)
				multirotorClient.simPause(true)
			} else {
				info("Actions received: " + actionFlagsCount)
			}
		]
	}

	on Destroy {
		//
	}
	
	/**
	 * When a drone emits the take-off instruction, transfers it to AirSim
	 */
	on Takeoff {
		markAction(occurrence.source)
		multirotorClient.takeoffAsync(20.0f, affectOrGetDrone(occurrence.source))
	}

	/** 
	 * When a drone emits the move-by-velocity instruction, transfers it to AirSim
	 */
	on MoveByVelocity {
		markAction(occurrence.source)
		multirotorClient.moveByVelocityAsync(
			occurrence.vx, occurrence.vy, occurrence.vz, occurrence.duration, DrivetrainType.MAX_DEGREE_OF_FREEDOM,
			new YawMode(), affectOrGetDrone(occurrence.source))
	}

	/** 
	 * When a drone emits the set-vehicle-pose instruction, transfers it to AirSim
	 */
	on SetVehiclePose {
		markAction(occurrence.source)
		multirotorClient.simSetVehiclePose(occurrence.pose, true, affectOrGetDrone(occurrence.source))
	}
	
	/**
	 * This function affects a drone to an agent (if it has no drone affected), or it returns the name of the
	 * affected drone in the other case.
	 */
	private def affectOrGetDrone(address : Address) {
		var name: String
		if (!affectedDrones.containsKey(address)) {
			synchronized (this.availableDrones) {
				name = availableDrones.pop()
			}
			info("Received affectation: " + address.UUID + " - " + name)
			affectedDrones.put(address, name)
			multirotorClient.enableApiControl(true, name)
		} else {
			name = affectedDrones.get(address)
		}
			
		return name
	}
	
	/** Flag an action */
	private def markAction(a: Address) {
		this.actionFlags.put(a, true)
	}
	
	/** Count the number of agents having performed an action */
	private def actionFlagsCount() {
		return this.actionFlags.values.filter[it === true].size
	}
	
	/** Reset the action flags */
	private def resetActionFlags() {
		this.actionFlags.clear
	}
}
