/** 
 * 
 */
package io.sarl.airsim

import fr.utbm.airsim.api.DrivetrainType
import fr.utbm.airsim.api.MultirotorClientInterface
import fr.utbm.airsim.api.YawMode
import io.sarl.airsim.influences.MoveByVelocity
import io.sarl.airsim.influences.Takeoff
import io.sarl.airsim.perceptions.LidarDataPerception
import io.sarl.core.DefaultContextInteractions
import io.sarl.core.Destroy
import io.sarl.core.Initialize
import io.sarl.core.Logging
import io.sarl.core.Schedules
import io.sarl.lang.core.Address
import org.msgpack.rpc.Client
import org.msgpack.rpc.loop.EventLoop
import io.sarl.airsim.perceptions.MultirotorStatePerception
import io.sarl.airsim.perceptions.sim.SimPosePerception
import io.sarl.airsim.perceptions.sim.SimGroundTruthKinematicsPerception
import io.sarl.airsim.influences.sim.SetVehiclePose
import java.util.Collections

/**
 * Agent in charge of controlling the simulation, transmitting the influences and
 * dispatching the perceptions 
 * @author Alexandre Lombard
 * 
 */
agent SimulationControllerAgent {
	uses Logging, DefaultContextInteractions, Schedules
	
	// Temporary solution to manage the affectation of the drones to the agents
	//val availableDrones = newLinkedList("Alpha", "Bravo", "Charly", "Delta", "Echo")
	//val availableDrones = newLinkedList("Alpha", "Charly", "Bravo", "Delta", "Echo")
	val availableDrones = newLinkedList("S0", "S1", "S2", "S3", "S4", "S5", "S6", "S7", "S8", "S9", "S10", "S11", "S12", "S13", "S14", "S15", "S16", "S17", "S18", "S19")
	val affectedDrones = <Address, String>newHashMap

	val loop = EventLoop.defaultEventLoop()

	val rpcClient = new Client("127.0.0.1", 41451, loop)
	val multirotorClient = rpcClient.proxy(typeof(MultirotorClientInterface))
	
	on Initialize {
		Collections.shuffle(availableDrones)

		every(100) [
			synchronized (this) {
				// Fetch the lidar data and propagate it
				affectedDrones.mapValues[multirotorClient.getLidarData("Lidar", it)].forEach [ k : Address, v |
					emit(new LidarDataPerception(v))[it == k]
				]

				// Fetch the multirotor state info and propagate it
				affectedDrones.mapValues[multirotorClient.getMultirotorState(it)].forEach [ k : Address, v |
					emit(new MultirotorStatePerception(v))[it == k]
				]

				// Fetch the sim pose and propagate it
				affectedDrones.mapValues[ multirotorClient.simGetObjectPose(it)].forEach [ k : Address, v |
					emit(new SimPosePerception(v))[it == k]
				]

				affectedDrones.mapValues[multirotorClient.simGetGroundTruthKinematics(it)].forEach [ k : Address, v |
					emit(new SimGroundTruthKinematicsPerception(v))[it == k]
				]
			}
		]
	}

	on Destroy {
		//
	}
	
	on Takeoff {
		multirotorClient.takeoffAsync(20.0f, affectOrGetDrone(occurrence.source))
	}
	
	on MoveByVelocity {
		multirotorClient.moveByVelocityAsync(
			occurrence.vx, occurrence.vy, occurrence.vz, occurrence.duration, DrivetrainType.MAX_DEGREE_OF_FREEDOM,
			new YawMode(), affectOrGetDrone(occurrence.source))
	}

	on SetVehiclePose {
		multirotorClient.simSetVehiclePose(occurrence.pose, true, affectOrGetDrone(occurrence.source))
	}
	
	/**
	 * This function affects a drone to an agent (if it has no drone affected), or it returns the name of the
	 * affected drone in the other case.
	 */
	synchronized def affectOrGetDrone(address : Address) {
		var name: String
		if (!affectedDrones.containsKey(address)) {
			name = availableDrones.pop()
			info("Received affectation: " + address.UUID + " - " + name)
			affectedDrones.put(address, name)
			multirotorClient.enableApiControl(true, name)
		} else {
			name = affectedDrones.get(address)
		}
			
		return name
	}
}
