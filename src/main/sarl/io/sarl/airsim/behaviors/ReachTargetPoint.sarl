/** 
 * 
 */
package io.sarl.airsim.behaviors

import fr.utbm.airsim.api.Vector3r
import io.sarl.core.Initialize
import io.sarl.core.Logging
import io.sarl.core.Schedules
import io.sarl.airsim.perceptions.sim.SimPosePerception
import fr.utbm.airsim.api.Pose
import io.sarl.airsim.perceptions.sim.SimGroundTruthKinematicsPerception
import fr.utbm.airsim.api.KinematicsState
import org.eclipse.xtend.lib.annotations.Accessors
import io.sarl.lang.core.Address
import io.sarl.core.DefaultContextInteractions
import io.sarl.airsim.communication.NotifyPose
import io.sarl.airsim.communication.NotifyKinematics
import io.sarl.airsim.influences.MoveByVelocity

/** 
 * Drone behavior: defines a target point (the opposite of the start point) and try to reach this target
 * Eventually avoids obstacles 
 * @author Alexandre Lombard
 * 
 */
behavior ReachTargetPoint {
	
	private val periodMs = 100

	var targetPoint: Vector3r = null
	
	// region Internal state of the agent
	var pose: Pose = new Pose()
	var velocity: Vector3r = new Vector3r()
	// endregion
	
	// region Data about the state of the other agents
	val neighbours = <Address, DroneState>newHashMap
	// endregion
	
	uses Logging, DefaultContextInteractions, Schedules

	on Initialize {
		every(periodMs) [
			val movementForce = computeForce()

			emit(new MoveByVelocity(movementForce.x, movementForce.y, 0.0f, periodMs / 1000.0f))
		]
	}

	on SimPosePerception {
		// Update the internal pose state and fix the target point if not set
		synchronized (this.pose) {
			this.pose = occurrence.pose	
			
			if(this.targetPoint === null) {
				this.targetPoint = new Vector3r(
					-this.pose.position.x,
					-this.pose.position.y,
					-this.pose.position.z)
			}
			
			emit(new NotifyPose(this.pose))
		}
	}
	
	on SimGroundTruthKinematicsPerception {
		// Update the internal velocity state
		synchronized (this.velocity) {
			this.velocity = occurrence.state.linearVelocity
			
			emit(new NotifyKinematics(occurrence.state))
		}
	}
	
	/**
	 * When the pose of another agent is received, we register it in the map of neighbours
	 */
	on NotifyPose {
		if(neighbours.containsKey(occurrence.source)) {
			neighbours.put(occurrence.source, new DroneState(neighbours.get(occurrence.source), occurrence.pose))
		} else {
			neighbours.put(occurrence.source, new DroneState(occurrence.pose, null))
		}
	}
	
	/**
	 * When the kinematic state of another agent is received, we register it in the map of neighbours
	 */
	on NotifyKinematics {
		if (neighbours.containsKey(occurrence.source)) {
			neighbours.put(occurrence.source, new DroneState(neighbours.get(occurrence.source), occurrence.state))
		} else {
			neighbours.put(occurrence.source, new DroneState(null as Pose, occurrence.state))
		}
	}
	
	def computeForce(): Vector3r {
		// Find among the neighbours if there are potentials obstacles and compute the time to collision
		val sliding = neighbours
				.mapValues [ 
					
					val selfPosition = this.pose.position
					val selfDirection = this.velocity
					val otherPosition = it.pose.position
					val otherDirection = it.state.linearVelocity
					
					val d = Math.abs(otherPosition.minus(selfPosition).cross(new Vector3r(selfDirection.x, selfDirection.y, 1)).dot(new Vector3r(otherDirection.x, otherDirection.y, 1))) /
							(new Vector3r(selfDirection.x, selfDirection.y, 1).cross(new Vector3r(otherDirection.x, otherDirection.y, 1)).length())
					
					if(d > 0.5) {
						// The minimal distance will be above 0.5 so there won't be a collision
						new Vector3r(0f, 0f, 0f)
					} else {
						// There may be a collision
						
						val coefA = Math.pow(selfDirection.x - otherDirection.x, 2) + Math.pow(selfDirection.y - otherDirection.y, 2)
						//val coefB = 2f * (selfPosition.x - otherPosition.x) * (selfDirection.x - otherDirection.x) + 2f * (selfPosition.y - otherPosition.y) * (selfDirection.y - otherDirection.y)
						var coefB = 2f * (selfPosition.x - otherPosition.x) * (selfDirection.x - otherDirection.x) + 2f * (selfPosition.y - otherPosition.y) * (selfDirection.y - otherDirection.y)
						
						val coefC = -Math.pow(d, 2)
						
						val delta = Math.pow(coefB, 2) - 4f * coefA * coefC
						val t = ((-coefB + Math.sqrt(delta)) / (2 * coefA)).floatValue
						
						val selfClosePosition = new Vector3r(selfPosition.x + selfDirection.x, selfPosition.y + selfDirection.y * t, t)
						val otherClosePosition = new Vector3r(otherPosition.x + otherDirection.x * t, otherPosition.y + otherDirection.y * t, t)
						
						val obstacleCloseDirection = otherClosePosition.minus(selfClosePosition).normalized()
						val slidingDirection = new Vector3r(-obstacleCloseDirection.y, obstacleCloseDirection.x, 0)
						
						val sigma = 1f
						val phi = 2f
						val tmax = 5f
						val slidingScale = (sigma / Math.pow(t, phi) - sigma / Math.pow(tmax, phi)).floatValue
						
						if(obstacleCloseDirection.y * targetPoint.x + slidingDirection.y * targetPoint.y >= 0) {
							slidingDirection.times(slidingScale)
						} else {
							slidingDirection.times(-slidingScale)
						}
					}
				].values.reduce[p1, p2 | new Vector3r(p1.x + p2.x, p1.y + p2.y, p1.z + p2.z)]

		val w = 1f
		val alpha = 1f
		val delta = Math.exp(-alpha / sliding.length())
		val attraction = targetPoint.minus(this.pose.position).times((w * delta).floatValue)

		return sliding.plus(attraction)
	}
	
}

/**
 * Internal class used to store the state of the other agents
 * @author Alexandre Lombard
 */
class DroneState {
	@Accessors(PUBLIC_GETTER)
	val pose : Pose
	@Accessors(PUBLIC_GETTER)
	val state: KinematicsState
	
	new(pose: Pose, state: KinematicsState) {
		this.pose = pose
		this.state = state
	}
	
	new(previousState: DroneState, pose: Pose) {
		this.pose = pose
		this.state = previousState.state
	}
	
	new(previousState: DroneState, kinematicsState: KinematicsState) {
		this.pose = previousState.pose
		this.state = kinematicsState
	}
}
